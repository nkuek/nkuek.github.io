/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import {
  useMemo,
  use,
  createContext,
  PropsWithChildren,
  useRef,
  useEffect,
} from "react";
import {
  useGLTF,
  Merged,
  MergedProps,
  InstanceProps,
  useTexture,
  Text,
} from "@react-three/drei";
import corneModel from "../../assets/corne.glb?url";
import * as THREE from "three";
import { ThreeElements, ThreeEvent, useFrame } from "@react-three/fiber";
import leftScreen from "../../assets/corne_screen_left.png";
import rightScreen from "../../assets/corne_screen_right.png";
import {
  createMirroredGeometry,
  ToGallium,
  FromGallium,
  MirroredKeys,
  mirrorPosition,
  mirrorRotation,
} from "./utils";
import { useControls } from "leva";
import { CorneContext, GLTFResult } from "./types";

const context = createContext<CorneContext | null>(null);

export function CorneInstances({
  children,
  inputRef,
  setText,
  ...props
}: PropsWithChildren<Omit<MergedProps, "children" | "meshes">> & {
  inputRef: React.RefObject<HTMLInputElement | null>;
  setText: React.Dispatch<React.SetStateAction<string>>;
}) {
  const { nodes } = useGLTF(corneModel) as unknown as GLTFResult;
  const instances = useMemo(() => {
    return {
      Switch: nodes.switch_1,
      Switch1: nodes.switch_2,
      Switch2: nodes.switch_3,
      BaseKey: nodes.b,
      Modifier: nodes.modifier,
    };
  }, [nodes]);

  return (
    <Merged {...props} meshes={instances}>
      {(instances) => (
        <context.Provider
          value={{ inputRef, setText, ...instances } as unknown as CorneContext}
        >
          {children}
        </context.Provider>
      )}
    </Merged>
  );
}

function Switch({ ...props }: InstanceProps) {
  const instances = use(context);
  if (!instances) {
    throw new Error("CorneInstances not found");
  }
  return (
    <group {...props} position={[0, -0.007, 0]}>
      <instances.Switch name="stem" />
      <instances.Switch1 name="base" />
      <instances.Switch2 name="cover" />
    </group>
  );
}

export default function CorneModel({
  flip,
  ...props
}: ThreeElements["group"] & { flip?: boolean }) {
  const contextValues = use(context);
  const { nodes, materials } = useGLTF(corneModel) as unknown as GLTFResult;

  const leftScreenTexture = useTexture(leftScreen);
  leftScreenTexture.flipY = false;

  const rightScreenTexture = useTexture(rightScreen);
  rightScreenTexture.flipY = false;

  const groupRef = useRef<THREE.Group>(null);
  const pressedEls = useRef<Map<string, { pressed: boolean; el: THREE.Group }>>(
    new Map(),
  );

  const { layout } = useControls({
    layout: {
      value: "Gallium",
      options: ["Gallium", "Qwerty"],
    },
  });

  if (!contextValues) {
    throw new Error("CorneInstances not found");
  }

  const { inputRef, setText, ...instances } = contextValues;

  const rotation = (Math.PI / 16) * (flip ? -1 : 1);
  const position = 1.65 * (flip ? 1 : -1);
  const texture = flip ? rightScreenTexture : leftScreenTexture;
  const filterKeys = [
    "display",
    "display_1",
    "case",
    "screen",
    "escape",
    "nice_nano",
    "Scene",
    "Volume",
    "space",
  ];

  function handlePointerDown(e: ThreeEvent<PointerEvent>) {
    e.stopPropagation();
    const target = e.target as Element;
    target.setPointerCapture(e.pointerId);
    const group = e.eventObject as THREE.Group;
    const name = group.name;
    pressedEls.current.set(name, { pressed: true, el: group });
    if (!inputRef.current || name.includes("modifier")) {
      return;
    }
    if (name === "backspace") {
      inputRef.current.value = inputRef.current.value.slice(0, -1);
      setText(inputRef.current.value);
      return;
    }
    inputRef.current.value += name === "space" ? " " : name;
    setText(inputRef.current.value);
  }

  function handlePointerUp(e: ThreeEvent<PointerEvent>) {
    e.stopPropagation();
    const target = e.target as Element;
    target.releasePointerCapture(e.pointerId);
    const group = e.eventObject as THREE.Group;
    const name = group.name;
    pressedEls.current.set(name, { pressed: false, el: group });
  }

  useFrame((_, delta) => {
    if (!pressedEls.current.size) return;
    pressedEls.current.forEach(({ el, pressed }) => {
      if (pressed) {
        el.position.y = Math.max(el.position.y - delta * 0.05, -0.0015);
      } else if (!pressed) {
        el.position.y = Math.min(el.position.y + delta * 0.1, 0);
        // need to delete the pressed element from the map when it is released since the key names change, but the mesh remains the same.
        if (el.position.y === 0) {
          pressedEls.current.delete(el.name);
        }
      }
    });
  });

  useEffect(() => {
    const abortController = new AbortController();
    function handleKey(e: KeyboardEvent, pressed = true) {
      if (!groupRef.current) return;
      let key = e.key.toLowerCase();
      if (e.key === " ") {
        key = "space";
      }
      const el = groupRef.current.getObjectByName(key) as THREE.Group;
      if (el) {
        pressedEls.current.set(key, { pressed, el });
      }
    }
    window.addEventListener("keydown", (e) => handleKey(e, true), {
      signal: abortController.signal,
    });
    window.addEventListener("keyup", (e) => handleKey(e, false), {
      signal: abortController.signal,
    });
    return () => {
      abortController.abort();
    };
  }, [layout]);

  return (
    <group
      {...props}
      dispose={null}
      scale={20}
      rotation={[0, rotation, 0]}
      position={[position, 0, 0]}
      ref={groupRef}
      castShadow
      receiveShadow
    >
      <group
        name="nice_nano"
        position={mirrorPosition(nodes.nice_nano.position, flip)}
      >
        <mesh
          name="display"
          castShadow
          receiveShadow
          geometry={nodes.display.geometry}
          material-map={texture}
        />
        <mesh
          name="display_1"
          castShadow
          receiveShadow
          geometry={nodes.display_1.geometry}
          material-map={texture}
          material={materials.pcb}
          material-color="#232b23"
        />
      </group>
      <mesh
        name="case"
        castShadow
        receiveShadow
        geometry={
          flip
            ? createMirroredGeometry(nodes.case.geometry)
            : nodes.case.geometry
        }
        material={materials.metal}
        position={mirrorPosition(nodes.case.position, flip)}
      />

      <mesh
        name="screen"
        castShadow
        receiveShadow
        geometry={
          flip
            ? createMirroredGeometry(nodes.screen.geometry)
            : nodes.screen.geometry
        }
        position={mirrorPosition(nodes.screen.position, flip)}
      >
        <meshPhysicalMaterial
          transparent
          opacity={0.5}
          ior={1.492}
          roughness={0.6}
        />
      </mesh>
      <mesh
        name="screen"
        castShadow
        receiveShadow
        geometry={
          flip
            ? createMirroredGeometry(nodes.screen.geometry)
            : nodes.screen.geometry
        }
        position={mirrorPosition(nodes.screen.position, flip)}
      >
        <meshPhysicalMaterial
          transparent
          opacity={0.5}
          ior={1.492}
          roughness={0.6}
        />
      </mesh>
      <group position={mirrorPosition(nodes.escape.position, flip)}>
        {flip ? (
          <instances.Modifier
            onPointerDown={handlePointerDown}
            onPointerUp={handlePointerUp}
            name="backspace"
            rotation={mirrorRotation(nodes.escape.rotation, flip)}
          />
        ) : (
          <mesh
            name="escape"
            geometry={nodes.escape.geometry}
            material={materials.fuji_keycap}
            onPointerDown={handlePointerDown}
            onPointerUp={handlePointerUp}
          />
        )}
        <Switch />
      </group>

      {/* All other keys */}
      {Object.entries(nodes)
        .filter(([key]) => !filterKeys.includes(key) && !key.includes("switch"))
        .map(([key, node]) => {
          let keyName = flip
            ? MirroredKeys[key as keyof typeof MirroredKeys]
            : key;
          if (layout !== "Gallium") {
            const dictionary = FromGallium[layout as keyof typeof FromGallium];
            keyName = dictionary[keyName as keyof typeof dictionary];
          }
          return (
            <group
              position={mirrorPosition(node.position, flip)}
              key={key}
              rotation={mirrorRotation(node.rotation, flip)}
              scale={node.scale}
              receiveShadow
              castShadow
            >
              <group>
                {key.includes("modifier") ? (
                  <instances.Modifier
                    onPointerDown={handlePointerDown}
                    onPointerUp={handlePointerUp}
                    name={keyName}
                  />
                ) : (
                  <instances.BaseKey
                    onPointerDown={handlePointerDown}
                    onPointerUp={handlePointerUp}
                    name={keyName}
                  >
                    <Text
                      scale={0.005}
                      rotation-x={-Math.PI / 2}
                      position-y={0.003}
                      depthOffset={0.01}
                      color="black"
                      renderOrder={5}
                    >
                      {keyName.toUpperCase()}
                    </Text>
                  </instances.BaseKey>
                )}
              </group>
              <Switch />
            </group>
          );
        })}
      <group
        position={mirrorPosition(nodes.space.position, flip)}
        rotation={mirrorRotation(nodes.space.rotation, flip)}
        receiveShadow
        castShadow
      >
        <mesh
          geometry={
            flip
              ? createMirroredGeometry(nodes.space.geometry)
              : nodes.space.geometry
          }
          material={materials.base_keycap}
          scale={nodes.space.scale}
          name="space"
          onPointerDown={handlePointerDown}
          onPointerUp={handlePointerUp}
        />
        <Switch />
      </group>
    </group>
  );
}

useGLTF.preload(corneModel);
