/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, {
  useMemo,
  use,
  createContext,
  PropsWithChildren,
  useRef,
} from "react";
import {
  useGLTF,
  Merged,
  MergedProps,
  InstanceProps,
  useTexture,
} from "@react-three/drei";
import corneModel from "../../assets/corne.glb?url";
import * as THREE from "three";
import { GLTF } from "three-stdlib";
import { ThreeElements } from "@react-three/fiber";
import leftScreen from "../../assets/corne_screen_left.png";
import rightScreen from "../../assets/corne_screen_right.png";
import {
  createMirroredGeometry,
  mirrorPosition,
  mirrorRotation,
} from "./utils";

type GLTFResult = GLTF & {
  nodes: {
    display: THREE.Mesh;
    display_1: THREE.Mesh;
    case: THREE.Mesh;
    screen: THREE.Mesh;
    escape: THREE.Mesh;
    b: THREE.Mesh;
    l: THREE.Mesh;
    d: THREE.Mesh;
    c: THREE.Mesh;
    v: THREE.Mesh;
    modifier: THREE.Mesh;
    n: THREE.Mesh;
    nice_nano: THREE.Mesh;
    r: THREE.Mesh;
    t: THREE.Mesh;
    s: THREE.Mesh;
    g: THREE.Mesh;
    modifier001: THREE.Mesh;
    x: THREE.Mesh;
    q: THREE.Mesh;
    m: THREE.Mesh;
    w: THREE.Mesh;
    z: THREE.Mesh;
    switch_1: THREE.Mesh;
    switch_2: THREE.Mesh;
    switch_3: THREE.Mesh;
    space: THREE.Mesh;
    modifier003: THREE.Mesh;
    modifier002: THREE.Mesh;
  };
  materials: {
    screen: THREE.MeshPhysicalMaterial;
    pcb: THREE.MeshStandardMaterial;
    metal: THREE.MeshStandardMaterial;
    keycap_stem: THREE.MeshStandardMaterial;
    keycap_base: THREE.MeshStandardMaterial;
    base_keycap: THREE.MeshStandardMaterial;
    fuji_keycap: THREE.MeshStandardMaterial;
    modifiers_keycap: THREE.MeshStandardMaterial;
  };
};
type CorneContext = {
  Switch: React.FC<InstanceProps>;
  Switch1: React.FC<InstanceProps>;
  Switch2: React.FC<InstanceProps>;
  BaseKey: React.FC<InstanceProps>;
  Modifier: React.FC<InstanceProps>;
  MirroredSwitch: React.FC<InstanceProps>;
  MirroredSwitch1: React.FC<InstanceProps>;
  MirroredSwitch2: React.FC<InstanceProps>;
  MirroredBaseKey: React.FC<InstanceProps>;
  MirroredModifier: React.FC<InstanceProps>;
};

const context = createContext<CorneContext | null>(null);

export function CorneInstances({
  children,
  ...props
}: PropsWithChildren<Omit<MergedProps, "children" | "meshes">>) {
  const { nodes } = useGLTF(corneModel) as unknown as GLTFResult;
  const instances = useMemo(() => {
    // Create mirrored versions of all instanced geometries
    const switch1Mirrored = new THREE.Mesh(
      createMirroredGeometry(nodes.switch_1.geometry),
      nodes.switch_1.material,
    );
    const switch2Mirrored = new THREE.Mesh(
      createMirroredGeometry(nodes.switch_2.geometry),
      nodes.switch_2.material,
    );
    const switch3Mirrored = new THREE.Mesh(
      createMirroredGeometry(nodes.switch_3.geometry),
      nodes.switch_3.material,
    );
    const baseKeyMirrored = new THREE.Mesh(
      createMirroredGeometry(nodes.b.geometry),
      nodes.b.material,
    );
    const modifierMirrored = new THREE.Mesh(
      createMirroredGeometry(nodes.modifier.geometry),
      nodes.modifier.material,
    );
    return {
      Switch: nodes.switch_1,
      Switch1: nodes.switch_2,
      Switch2: nodes.switch_3,
      BaseKey: nodes.b,
      Modifier: nodes.modifier,
      // Mirrored instances
      MirroredSwitch: switch1Mirrored,
      MirroredSwitch1: switch2Mirrored,
      MirroredSwitch2: switch3Mirrored,
      MirroredBaseKey: baseKeyMirrored,
      MirroredModifier: modifierMirrored,
    };
  }, [nodes]);
  return (
    <Merged {...props} meshes={instances}>
      {(instances) => (
        <context.Provider value={instances as unknown as CorneContext}>
          {children}
        </context.Provider>
      )}
    </Merged>
  );
}

function Switch({
  mirrored = false,
  ...props
}: InstanceProps & { mirrored?: boolean }) {
  const instances = use(context);
  if (!instances) {
    throw new Error("CorneInstances not found");
  }
  return (
    <group {...props} position={[0, -0.007, 0]}>
      {mirrored ? (
        <>
          <instances.MirroredSwitch name="switch_1" />
          <instances.MirroredSwitch1 name="switch_2" />
          <instances.MirroredSwitch2 name="switch_3" />
        </>
      ) : (
        <>
          <instances.Switch name="switch_1" />
          <instances.Switch1 name="switch_2" />
          <instances.Switch2 name="switch_3" />
        </>
      )}
    </group>
  );
}

export default function CorneModel({
  flip,
  ...props
}: ThreeElements["group"] & { flip?: boolean }) {
  const instances = use(context);
  const { nodes, materials } = useGLTF(corneModel) as unknown as GLTFResult;

  const leftScreenTexture = useTexture(leftScreen);
  leftScreenTexture.flipY = false;

  const rightScreenTexture = useTexture(rightScreen);
  rightScreenTexture.flipY = false;

  const groupRef = useRef<THREE.Group>(null);

  if (!instances) {
    throw new Error("CorneInstances not found");
  }

  const rotation = (Math.PI / 16) * (flip ? -1 : 1);
  const position = 1.65 * (flip ? 1 : -1);
  const texture = flip ? rightScreenTexture : leftScreenTexture;
  const filterKeys = [
    "display",
    "display_1",
    "case",
    "screen",
    "escape",
    "nice_nano",
    "Scene",
    "Volume",
    "space",
  ];
  return (
    <group
      {...props}
      dispose={null}
      scale={20}
      rotation={[0, rotation, 0]}
      position={[position, 0, 0]}
      ref={groupRef}
      castShadow
      receiveShadow
    >
      <group
        name="nice_nano"
        position={mirrorPosition(nodes.nice_nano.position, flip)}
      >
        <mesh
          name="display"
          castShadow
          receiveShadow
          geometry={nodes.display.geometry}
          material-map={texture}
        />
        <mesh
          name="display_1"
          castShadow
          receiveShadow
          geometry={nodes.display_1.geometry}
          material-map={texture}
        />
      </group>
      <mesh
        name="case"
        castShadow
        receiveShadow
        geometry={
          flip
            ? createMirroredGeometry(nodes.case.geometry)
            : nodes.case.geometry
        }
        material={materials.metal}
        position={mirrorPosition(nodes.case.position, flip)}
      />

      <mesh
        name="screen"
        castShadow
        receiveShadow
        geometry={
          flip
            ? createMirroredGeometry(nodes.screen.geometry)
            : nodes.screen.geometry
        }
        position={mirrorPosition(nodes.screen.position, flip)}
      >
        <meshPhysicalMaterial
          transparent
          opacity={0.5}
          ior={1.492}
          roughness={0.6}
        />
      </mesh>
      <mesh
        name="screen"
        castShadow
        receiveShadow
        geometry={
          flip
            ? createMirroredGeometry(nodes.screen.geometry)
            : nodes.screen.geometry
        }
        position={mirrorPosition(nodes.screen.position, flip)}
      >
        <meshPhysicalMaterial
          transparent
          opacity={0.5}
          ior={1.492}
          roughness={0.6}
        />
      </mesh>
      <group position={mirrorPosition(nodes.escape.position, flip)}>
        {flip ? (
          <>
            <instances.MirroredModifier />
            <Switch mirrored={true} />
          </>
        ) : (
          <>
            <mesh
              name="escape"
              geometry={nodes.escape.geometry}
              material={materials.fuji_keycap}
            />
            <Switch mirrored={false} />
          </>
        )}
      </group>

      {/* All other keys */}
      {Object.entries(nodes)
        .filter(([key]) => !filterKeys.includes(key) && !key.includes("switch"))
        .map(([key, node]) => {
          return (
            <group
              position={mirrorPosition(node.position, flip)}
              key={key}
              name={key}
              rotation={mirrorRotation(node.rotation, flip)}
              scale={node.scale}
              receiveShadow
              castShadow
            >
              {key.includes("modifier") ? (
                flip ? (
                  <instances.MirroredModifier />
                ) : (
                  <instances.Modifier />
                )
              ) : flip ? (
                <instances.MirroredBaseKey />
              ) : (
                <instances.BaseKey />
              )}
              <Switch mirrored={flip} />
            </group>
          );
        })}

      {/* Space key */}
      <group
        position={mirrorPosition(nodes.space.position, flip)}
        rotation={mirrorRotation(nodes.space.rotation, flip)}
        receiveShadow
        castShadow
      >
        <mesh
          geometry={
            flip
              ? createMirroredGeometry(nodes.space.geometry)
              : nodes.space.geometry
          }
          material={materials.base_keycap}
          scale={nodes.space.scale}
          name="space"
        />
        <Switch mirrored={flip} />
      </group>
    </group>
  );
}

useGLTF.preload(corneModel);
