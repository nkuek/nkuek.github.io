/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useMemo, use, createContext, PropsWithChildren } from "react";
import {
  useGLTF,
  Merged,
  MergedProps,
  InstanceProps,
  useTexture,
} from "@react-three/drei";
import corneModel from "../../assets/corne.glb?url";
import * as THREE from "three";
import { GLTF } from "three-stdlib";
import { ThreeElements } from "@react-three/fiber";
import leftScreen from "../../assets/corne_screen_left.png";
import rightScreen from "../../assets/corne_screen_right.png";

type GLTFResult = GLTF & {
  nodes: {
    display: THREE.Mesh;
    display_1: THREE.Mesh;
    case: THREE.Mesh;
    screen: THREE.Mesh;
    escape: THREE.Mesh;
    b: THREE.Mesh;
    l: THREE.Mesh;
    d: THREE.Mesh;
    c: THREE.Mesh;
    v: THREE.Mesh;
    modifier: THREE.Mesh;
    n: THREE.Mesh;
    nice_nano: THREE.Mesh;
    r: THREE.Mesh;
    t: THREE.Mesh;
    s: THREE.Mesh;
    g: THREE.Mesh;
    modifier001: THREE.Mesh;
    x: THREE.Mesh;
    q: THREE.Mesh;
    m: THREE.Mesh;
    w: THREE.Mesh;
    z: THREE.Mesh;
    switch_1: THREE.Mesh;
    switch_2: THREE.Mesh;
    switch_3: THREE.Mesh;
    space: THREE.Mesh;
    modifier003: THREE.Mesh;
    modifier002: THREE.Mesh;
  };
  materials: {
    screen: THREE.MeshPhysicalMaterial;
    pcb: THREE.MeshStandardMaterial;
    metal: THREE.MeshStandardMaterial;
    keycap_stem: THREE.MeshStandardMaterial;
    keycap_base: THREE.MeshStandardMaterial;
    base_keycap: THREE.MeshStandardMaterial;
    fuji_keycap: THREE.MeshStandardMaterial;
    modifiers_keycap: THREE.MeshStandardMaterial;
  };
};
type CorneContext = {
  Switch: React.FC<InstanceProps>;
  Switch1: React.FC<InstanceProps>;
  Switch2: React.FC<InstanceProps>;
  BaseKey: React.FC<InstanceProps>;
  Modifier: React.FC<InstanceProps>;
};

const context = createContext<CorneContext | null>(null);
export function CorneInstances({
  children,
  ...props
}: PropsWithChildren<Omit<MergedProps, "children" | "meshes">>) {
  const { nodes } = useGLTF(corneModel);
  const instances = useMemo(
    () => ({
      Switch: nodes.switch_1,
      Switch1: nodes.switch_2,
      Switch2: nodes.switch_3,
      BaseKey: nodes.b,
      Modifier: nodes.modifier,
    }),
    [nodes],
  );
  return (
    <Merged {...props} meshes={instances}>
      {(instances) => (
        <context.Provider value={instances as unknown as CorneContext}>
          {children}
        </context.Provider>
      )}
    </Merged>
  );
}

function Switch(props: InstanceProps) {
  const instances = use(context);
  if (!instances) {
    throw new Error("CorneInstances not found");
  }
  return (
    <group {...props} position={[0, -0.007, 0]}>
      <instances.Switch name="switch_1" />
      <instances.Switch1 name="switch_2" />
      <instances.Switch2 name="switch_3" />
    </group>
  );
}

export default function Model({
  flip,
  ...props
}: ThreeElements["group"] & { flip?: boolean }) {
  const instances = use(context);
  const { nodes, materials } = useGLTF(corneModel) as unknown as GLTFResult;

  const leftScreenTexture = useTexture(leftScreen);
  leftScreenTexture.flipY = false;

  const rightScreenTexture = useTexture(rightScreen);
  rightScreenTexture.flipY = false;

  if (!instances) {
    throw new Error("CorneInstances not found");
  }

  const rotation = (Math.PI / 16) * (flip ? -1 : 1);
  const position = 1.65 * (flip ? 1 : -1);
  const texture = flip ? rightScreenTexture : leftScreenTexture;
  const filterKeys = [
    "display",
    "display_1",
    "case",
    "screen",
    "escape",
    "nice_nano",
    "Scene",
    "Volume",
    "space",
  ];
  return (
    <group
      {...props}
      dispose={null}
      scale={flip ? [-20, 20, 20] : [20, 20, 20]}
      rotation={[0, rotation, 0]}
      position={[position, 0, 0]}
    >
      <group name="nice_nano" position={nodes.nice_nano.position}>
        <mesh
          name="display"
          castShadow
          receiveShadow
          geometry={nodes.display.geometry}
          material-map={texture}
        />
        <mesh
          name="display_1"
          castShadow
          receiveShadow
          geometry={nodes.display_1.geometry}
          material-map={texture}
        />
      </group>
      <mesh
        name="case"
        castShadow
        receiveShadow
        geometry={nodes.case.geometry}
        material={materials.metal}
        position={nodes.case.position}
      />
      <mesh
        name="screen"
        castShadow
        receiveShadow
        geometry={nodes.screen.geometry}
        position={nodes.screen.position}
      >
        <meshPhysicalMaterial
          transparent
          opacity={0.5}
          ior={1.492}
          roughness={0.6}
        />
      </mesh>
      <group position={nodes.escape.position}>
        {flip ? (
          <instances.Modifier />
        ) : (
          <mesh
            name="escape"
            geometry={nodes.escape.geometry}
            material={materials.fuji_keycap}
          />
        )}
        <Switch />
      </group>
      {Object.entries(nodes)
        .filter(([key]) => !filterKeys.includes(key) && !key.includes("switch"))
        .map(([key, node]) => {
          return (
            <group
              position={node.position}
              key={key}
              name={key}
              rotation={node.rotation}
              scale={node.scale}
            >
              {key.includes("modifier") ? (
                <instances.Modifier />
              ) : (
                <instances.BaseKey />
              )}
              <Switch />
            </group>
          );
        })}
      <group position={nodes.space.position} rotation={nodes.space.rotation}>
        <mesh
          geometry={nodes.space.geometry}
          material={materials.base_keycap}
          scale={nodes.space.scale}
          name="space"
        />
        <Switch />
      </group>
    </group>
  );
}

useGLTF.preload(corneModel);
